<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// ======
//
// Copyright (c) Timothy Baxendale. All Rights Reserved.
//
// ======
using System;
using Tint.Runtime;

namespace Tint.Types
{
    // Autogenerated. Do not modify this file.
    internal static class TypeConvert
    {
<# BuildAll(); #>

        internal static object ConvertFromString(string str)
        {
            // now we've just got to parse the supported types until we find a match...
            Number n;
            if (Number.TryParse(str, out n))
                return n;
            bool b;
            if (bool.TryParse(str, out b))
                return b;
            return null;
        }
    }
}
<#+
    void BuildAll()
    {
        BuildTryConvert("<T>", "", "", "T", "typeof(T)", "(T)");
        WriteLine("");
        BuildTryConvert("", "Type", "type", "object", "type", "");
        WriteLine("");
        BuildTryConvertNonStrict("<T>", "", "T", "typeof(T)", "(T)");
        WriteLine("");
        BuildTryConvertNonStrict("", " Type type,", "object", "type", "");
    }
#>
<#+
    void BuildTryConvert(string genericParam, string extraParamType, string extraParamName, string typename, string getType, string cast)
    {
        string docnode;
        if (genericParam == "") {
            docnode = "param";
        }
        else {
            docnode = "typeparam";
            extraParamName = typename;
        }

        string extraParam = "";
        if (extraParamType != "") {
            extraParam = $" {extraParamType} {extraParamName},";
        }
#>
        internal static bool TryConvert<#= genericParam #>(object obj,<#= extraParam #> out <#= typename #> result, ExecuterOption opts)
        {
            return TryConvert(
                obj,
<#+ if (extraParam != "") { #>
                <#= extraParamName #>, 
<#+ } #>
                out result,
                opts.HasFlag(ExecuterOption.Strict),
                !opts.HasFlag(ExecuterOption.EnforceStrings)
            );
        }

        /// <summary>
        /// Tries to convert an object to a given type. First this tries to do a straight up cast. If that doesn't work and strict is turned off, it will try to be converted with IConvertible. If the object is a string and parseStrings is turned on, it will try to parse that string.
        /// </summary>
        /// <<#= docnode #> name="<#= extraParamName #>">the type to convert to</<#= docnode #>>
        /// <param name="obj">the object to convert</param>
        /// <param name="result">the result of the conversion</param>
        /// <param name="strict">wether the type should attempt to be converted</param>
        /// <param name="parseStrings">determines whether strings should try to be converted</param>
        /// <returns></returns>
        internal static bool TryConvert<#= genericParam #>(object obj, <#= extraParam #> out <#= typename #> result, bool strict, bool parseStrings)
        {
<#+ if (extraParam == "") { #>
            if (obj is <#= typename #>) {
<#+ } else { #>
            if (<#= extraParamName #>.IsAssignableFrom(obj.GetType())) {
<#+ } #>
                result = <#= cast #>obj;
                return true;
            }
            else {
                if (!strict)
                    return TryConvertNonStrict(
                                obj,
<#+ if (extraParam != "") { #>
                                <#= extraParamName #>,
<#+ } #>
                                out result,
                                parseStrings
                            );
                result = default(<#= typename #>);
                return false;
            }
        }
<#+
    }



    private void BuildTryConvertNonStrict(string genericParam, string extraParam, string typename, string getType, string cast)
    {
        #>

        private static bool TryConvertNonStrict<#= genericParam #>(object obj, <#= extraParam #> out <#= typename #> result, bool parseStrings = true)
        {
            result = default(<#= typename #>);
            if (parseStrings) {
                string str = obj as string; // maybe we can convert it from a string?
                if (str != null) {
                    obj = ConvertFromString(str);
                    if (obj == null)
                        return false;
                    return TryConvert(obj, out result, strict: false, parseStrings: false); // it's a good old fashion type now. try again.
                }
            }
            if (obj is IConvertible) {
                try {
                    result = <#= cast #>Convert.ChangeType(obj, <#= getType #>);
                    return true;
                }
                catch(InvalidCastException) {
                    if (<#= getType #>.IsEnum) {
                        Number? n = obj as Number?;
                        if (n != null) {
                            return TryConvert((int)n, out result, strict: true, parseStrings: false); // if we don't turn on strict, we'll have infinite recursion 8/22/16
                        }
                    }
                    return false;
                }
                catch (Exception ex) when (ex is FormatException || ex is OverflowException) {
                    return false;
                }
            }
            else {
                return false;
            }
        }
<#+ }
#>