<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// ======
//
// Copyright (c) Timothy Baxendale. All Rights Reserved.
//
// ======
using System;
using Tbasic.Runtime;

namespace Tbasic.Types
{
    // Autogenerated. Do not modify this file.

    /// <summary>
    /// Represents a number that can be used in operations quickly at the cost of precision
    /// </summary>
<# BuildType("FastNumber", "double", "Double"); #>

    /// <summary>
    /// Represents a number that can be represented precisely at the cost of performance
    /// </summary>
<# BuildType("PreciseNumber", "decimal", "Decimal"); #>
}

<#+ private void BuildType(string classname, string primitive, string primitiveName) { #>
	#region <#= classname #>
    public struct <#= classname #> : INumber, IComparable<<#= classname #>>, IComparable<<#= primitive #>>, IEquatable<<#= classname #>>, IEquatable<<#= primitive #>>
    {
        /// <summary>
        /// Gets or sets the value this <#= classname #> represents
        /// </summary>
        public <#= primitive #> Value;
        /// <summary>
        /// Gets the size of the type that represents this number
        /// </summary>
        public const int SIZE = sizeof(<#= primitive #>);
        
        /// <summary>
        /// Constructs a new number
        /// </summary>
        public <#= classname #>(<#= primitive #> value)
        {
            Value = value;
        }

        /// <summary>
        /// Determines if this number has a fractional part
        /// </summary>
        public bool HasFraction()
        {
            return Value % 1 != 0;
        }

		/// <summary>
		/// Gets a bool indicating whether or not the value of this number is 0
		/// </summary>
		public bool IsZero()
		{
			return Value == 0;
		}

		/// <summary>
		/// Converts this <#= classname #> to an int.
		/// </summary>
		/// <exception cref="ArgumentException">the value contains a fractional part</exception>
		/// <exception cref="OverflowException">the value was too large to store in an int</exception>
		public int ForceToInt()
		{
			if (HasFraction())
				throw new ArgumentException("Number contains a fractional part and cannot be used as an int");
			return (int)Value;
		}

        /// <summary>
        /// Converts this number to whichever primitive type seems most appropriate (either an integer type or a <#= primitive #>)
        /// </summary>
        public object ToPrimitive()
        {
			if (HasFraction()) {
				if (Value <= int.MaxValue) {
					return (int)Value;
				}
				else {
					return (long)Value;
				}
			}
            return Value;
        }

        /// <summary>
        /// Tries to parse a string as a number
        /// </summary>
        public static bool TryParse(string s, out <#= classname #> result)
        {
            <#= primitive #> d;
            if (<#= primitive #>.TryParse(s, out d)) {
                result = new <#= classname #>(d);
                return true;
            }
            else {
                result = default(<#= classname #>);
                return false;
            }
        }

        /// <summary>
        /// Parses a string as a number
        /// </summary>
        public static <#= classname #> Parse(string s)
        {
            return <#= primitive #>.Parse(s);
        }

        /// <summary>
        /// Determines if an object can be stored in a <#= classname #>
        /// </summary>
        public static bool Is<#= classname #>(object o, ExecuterOption opts)
        {
            <#= primitive #> d;
            return TypeConvert.TryConvert(o, out d, opts);
        }

        /// <summary>
        /// Attempts to convert an object to a <#= classname #>. Returns null if no conversion is possible.
        /// </summary>
        public static <#= classname #>? As<#= classname #>(object o, ExecuterOption opts)
        {
            <#= primitive #> d;
            if (TypeConvert.TryConvert(o, out d, opts)) {
                return new <#= classname #>(d);
            }
            else {
                return null;
            }
        }

        /// <summary>
        /// Converts this number to a string representation
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            if (HasFraction())
                return Value.ToString();
            return ((long)Value).ToString();
        }

        #region IComparable

        /// <summary>
        /// Compares this <#= classname #> with another object
        /// </summary>
        public int CompareTo(object obj)
        {
            <#= classname #>? n = obj as <#= classname #>?;
            if (n != null)
                return CompareTo(n);

			<#= primitive #>? primitive = obj as <#= primitive #>?;
            if (primitive != null)
                return CompareTo(primitive);

			INumber inum = obj as INumber;
			if (inum != null)
				return CompareTo(inum);

            throw new ArgumentException(string.Format("can only compare types {0} or {1}", typeof(<#= classname #>).Name, typeof(<#= primitive #>).Name));
        }

        /// <summary>
        /// Compares this <#= classname #> to another <#= classname #>
        /// </summary>
        public int CompareTo(<#= classname #> other)
        {
            return Value.CompareTo(other.Value);
        }

        /// <summary>
        /// Compares this <#= classname #> to a <#= primitive #>
        /// </summary>
        public int CompareTo(<#= primitive #> other)
        {
            return Value.CompareTo(other);
        }

        /// <summary>
        /// Compares this <#= classname #> to another INumber
        /// </summary>
        public int CompareTo(INumber other)
        {
            return Value.CompareTo((<#= primitive #>)Convert.ChangeType(other, typeof(<#= primitive #>)));
        }

        #endregion

        #region IEquatable

        /// <summary>
        /// Determines if this number is equal to another
        /// </summary>
        public bool Equals(<#= classname #> other)
        {
            return Value == other.Value;
        }

        /// <summary>
        /// Determines if this number is equal to a <#= primitive #>
        /// </summary>
        public bool Equals(<#= primitive #> other)
        {
            return Value == other;
        }

		/// <summary>
        /// Determines if this number is equal to another INumber
        /// </summary>
        public bool Equals(INumber other)
        {
            return Value == (<#= primitive #>)Convert.ChangeType(other, typeof(<#= primitive #>));
        }
        
        /// <summary>
        /// Determines if these two objects are equal
        /// </summary>
        public override bool Equals(object obj)
        {
            <#= classname #>? n = obj as <#= classname #>?;
            if (n != null)
                return Equals(n.Value);

            <#= primitive #>? primitive = obj as <#= primitive #>?;
            if (primitive != null)
                return Equals(primitive);

			INumber inum = obj as INumber;
			if (inum != null)
				return Equals(inum);

            return base.Equals(obj);
        }

        /// <summary>
        /// Gets the hash code for this number
        /// </summary>
        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        #endregion

        #region IConvertable
        
        TypeCode IConvertible.GetTypeCode()
        {
            return Value.GetTypeCode();
        }

        object IConvertible.ToType(Type conversionType, IFormatProvider provider)
        {
            return ((IConvertible)Value).ToType(conversionType, provider);
        }

        string IConvertible.ToString(IFormatProvider provider)
        {
            return Value.ToString(provider);
        }

<#+ string[] types = { "Boolean", "Char", "SByte", "Byte", "Int16", "UInt16", "Int32", "UInt32", "Int64", "UInt64", "Single", "Double", "Decimal", "DateTime" };
	foreach (string type in types) { #>
        <#= type #> IConvertible.To<#= type #>(IFormatProvider provider)
        {
            return ((IConvertible)Value).To<#= type #>(provider);
        }

<#+ } #>
        #endregion

        #region Comparison operators

<#+ BuildComparisonOp("equal to", primitiveName, "", "==", classname, ".Value");
	BuildComparisonOp("not equal to", primitiveName, "", "!=", classname, ".Value");
	BuildComparisonOp("greater than", primitiveName, "GreaterThan", ">", classname, ".Value");
	BuildComparisonOp("less than", primitiveName, "LessThan", "<", classname, ".Value");
	BuildComparisonOp("greater than or equal to", primitiveName, "GreaterThanOrEqualTo", ">=", classname, ".Value");
	BuildComparisonOp("less than or equal to", primitiveName, "LessThanOrEqualTo", "<=", classname, ".Value");
#>
        #endregion

        #region Arithemetic operators

<#+ BuildArithmeticOp("Add", "+", classname, primitive, primitiveName);
	BuildArithmeticOp("Subtract", "-", classname, primitive, primitiveName);
	BuildArithmeticOp("Multiply", "*", classname, primitive, primitiveName);
	BuildArithmeticOp("Divide", "/", classname, primitive, primitiveName);
	BuildArithmeticOp("Mod", "%", classname, primitive, primitiveName);
#>
        #endregion

		#region Conversion operators

        /// <summary>
        /// Implicitly converts a <#= primitive #> to a <#= classname #>
        /// </summary>
        public static implicit operator <#= classname #>(<#= primitive #> d)
        {
            return new <#= classname #>(d);
        }

        /// <summary>
        /// Implicitly converts a <#= classname #> to a <#= primitive #>
        /// </summary>
        public static implicit operator <#= primitive #>(<#= classname #> num)
        {
            return num.Value;
        }

<#+
string[] intTypes = { "sbyte", "short", "int", "long" };

foreach(string type in intTypes) { #>
        /// <summary>
        /// Converts <#= type #> to a <#= classname #>
        /// </summary>
        public static implicit operator <#= classname #>(<#= type #> n)
        {
            return new <#= classname #>(n);
        }
<#+ } #>
		#endregion
    }
	
	#endregion
<#+ } #>

<#+ private void BuildComparisonOp(string details, string primitivename, string methodname, string op, string firsttype, string firstconv, string secondtype = null, string secondconv = null)
    {
		if (secondtype == null) {
			secondtype = firsttype;
			secondconv = firstconv;
		}
#>
		/// <summary>
        /// Determines if one number is <#= details #> another
        /// </summary>
        public static bool operator <#= op #>(<#= firsttype #> left, <#= secondtype #> right)
        {
            return left<#= firstconv #> <#= op #> right<#= secondconv #>;
        }

<#+ if (methodname != "") { #>
		bool INumber.<#= methodname #>(INumber operand)
		{
			return Value <#= op #> Convert.To<#= primitivename #>(operand);
		}

<#+ } #>
<#+ } #>

<#+ private void BuildArithmeticOp(string verb, string op, string classname, string primitive, string primitiveName)
    {
#>
		/// <summary>
        /// <#= verb #>s one <#= classname #> with another
        /// </summary>
        public static <#= classname #> operator <#= op #>(<#= classname #> left, <#= classname #> right)
        {
            return new <#= classname #>(left.Value <#= op #> right.Value);
        }

		/// <summary>
        /// <#= verb #>s a <#= classname #> with a <#= primitive #>
        /// </summary>
        public static <#= classname #> operator <#= op #>(<#= classname #> left, <#= primitive #> right)
        {
            return new <#= classname #>(left.Value <#= op #> right);
        }

		/// <summary>
        /// <#= verb #>s a <#= classname #> with a <#= primitive #>
        /// </summary>
        public static <#= classname #> operator <#= op #>(<#= primitive #> left, <#= classname #> right)
        {
            return new <#= classname #>(left <#= op #> right.Value);
        }

		INumber INumber.<#= verb #>(INumber operand)
		{
			return new <#= classname #>(Value <#= op #> Convert.To<#= primitiveName #>(operand));
		}

<#+ } #>