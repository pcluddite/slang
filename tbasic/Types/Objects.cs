/** +++====+++
 *  
 *  Copyright (c) Timothy Baxendale
 *
 *  +++====+++
**/
using System;
using System.Globalization;

namespace Tbasic.Types
{
    // Autogenerated. Do not modify this file.

    /// <summary>
    /// The runtime object for a double
    /// </summary>
    public partial struct Number
        : ITObject, IConvertible, IComparable, IComparable<Number>, IComparable<double>, IEquatable<Number>, IEquatable<double>
    {
        /// <summary>
        /// The value this Number wraps
        /// </summary>
        public double Value;

        /// <summary>
        /// Initializes a new Number object
        /// </summary>
        public Number(double value)
        {
            Value = value;
        }

        Type ITObject.Native => typeof(double);

        bool IConvertible.ToBoolean(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToBoolean(provider);
        }

        char IConvertible.ToChar(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToChar(provider);
        }

        sbyte IConvertible.ToSByte(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToSByte(provider);
        }

        byte IConvertible.ToByte(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToByte(provider);
        }

        short IConvertible.ToInt16(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToInt16(provider);
        }

        int IConvertible.ToInt32(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToInt32(provider);
        }

        long IConvertible.ToInt64(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToInt64(provider);
        }

        ushort IConvertible.ToUInt16(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToUInt16(provider);
        }

        uint IConvertible.ToUInt32(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToUInt32(provider);
        }

        ulong IConvertible.ToUInt64(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToUInt64(provider);
        }

        float IConvertible.ToSingle(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToSingle(provider);
        }

        double IConvertible.ToDouble(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToDouble(provider);
        }

        decimal IConvertible.ToDecimal(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToDecimal(provider);
        }

        DateTime IConvertible.ToDateTime(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToDateTime(provider);
        }

        string IConvertible.ToString(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToString(provider);
        }

        TypeCode IConvertible.GetTypeCode()
        {
            return Value.GetTypeCode();
        }

        object IConvertible.ToType(Type conversionType, IFormatProvider provider)
        {
            return ((IConvertible)Value).ToType(conversionType, provider);
        }
        /// <summary>
        /// Determines if this Number object is equal to another
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(Number other)
        {
            return Value == other.Value;
        }

        /// <summary>
        /// Determines if this Number object is equal to a double
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(double other)
        {
            return Value == other;
        }
        
        /// <summary>
        /// Determines if these two objects are equal
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
            Number? n = obj as Number?;
            if (n != null)
                return Equals(n.Value);

            double? v = obj as double?;
            if (v != null)
                return Equals(v.Value);

            return false;
        }

        /// <summary>
        /// Gets the hash code for this Number object
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }
        /// <summary>
        /// Compares this Number with another object
        /// </summary>
        /// <param name="obj">the other object</param>
        /// <returns></returns>
        public int CompareTo(object obj)
        {
            Number? n = obj as Number?;
            if (n != null)
                return CompareTo(n.Value);

            double? d = obj as double?;
            if (n != null)
                return CompareTo(d.Value);

            throw new ArgumentException($"Cannot compare types {nameof(Number)} and \"{TypeUtil.NameOf(obj)}\"");
        }

        /// <summary>
        /// Compares this Number object to another Number object
        /// </summary>
        /// <param name="other">the other Number object</param>
        /// <returns></returns>
        public int CompareTo(Number other)
        {
            return Value.CompareTo(other.Value);
        }

        /// <summary>
        /// Compares this Number to a double
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public int CompareTo(double other)
        {
            return Value.CompareTo(other);
        }

        /// <summary>
        /// Implicitly converts a double to a Number
        /// </summary>
        /// <param name="value"></param>
        public static implicit operator Number(double value)
        {
            return new Number(value);
        }

        /// <summary>
        /// Implicitly converts a Number to a double
        /// </summary>
        /// <param name="value"></param>
        public static implicit operator double(Number value)
        {
            return value.Value;
        }
        /// <summary>
        /// Determines if one Number object is equal to another Number object
        /// </summary>
        /// <param name="left">the left operand</param>
        /// <param name="right">the right operand</param>
        /// <returns>a boolean value indicating if the expression is true of false</returns>
        public static bool operator ==(Number left, Number right)
        {
            return left.Value == right.Value;
        }

        /// <summary>
        /// Determines if one Number object is not equal to another Number object
        /// </summary>
        /// <param name="left">the left operand</param>
        /// <param name="right">the right operand</param>
        /// <returns>a boolean value indicating if the expression is true of false</returns>
        public static bool operator !=(Number left, Number right)
        {
            return left.Value != right.Value;
        }

        /// <summary>
        /// Determines if one Number object is greater than another Number object
        /// </summary>
        /// <param name="left">the left operand</param>
        /// <param name="right">the right operand</param>
        /// <returns>a boolean value indicating if the expression is true of false</returns>
        public static bool operator >(Number left, Number right)
        {
            return left.Value > right.Value;
        }

        /// <summary>
        /// Determines if one Number object is less than another Number object
        /// </summary>
        /// <param name="left">the left operand</param>
        /// <param name="right">the right operand</param>
        /// <returns>a boolean value indicating if the expression is true of false</returns>
        public static bool operator <(Number left, Number right)
        {
            return left.Value < right.Value;
        }

        /// <summary>
        /// Determines if one Number object is greater than or equal to another Number object
        /// </summary>
        /// <param name="left">the left operand</param>
        /// <param name="right">the right operand</param>
        /// <returns>a boolean value indicating if the expression is true of false</returns>
        public static bool operator >=(Number left, Number right)
        {
            return left.Value >= right.Value;
        }

        /// <summary>
        /// Determines if one Number object is less than or equal to another Number object
        /// </summary>
        /// <param name="left">the left operand</param>
        /// <param name="right">the right operand</param>
        /// <returns>a boolean value indicating if the expression is true of false</returns>
        public static bool operator <=(Number left, Number right)
        {
            return left.Value <= right.Value;
        }


        /// <summary>
        /// Tries to parse a string as a Number object
        /// </summary>
        /// <param name="str"></param>
        /// <param name="result"></param>
        /// <returns></returns>
        public static bool TryParse(string str, out Number result)
        {
            result = default;
            if (double.TryParse(str, out double native)) {
                result = native;
                return true;
            }
            return false;
        }

        /// <summary>
        /// Parses a string as a Number object
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        public static Number Parse(string str)
        {
            return double.Parse(str);
        }
    }

    /// <summary>
    /// The runtime object for a DateTime
    /// </summary>
    public struct Time
        : ITObject, IConvertible, IComparable, IComparable<Time>, IComparable<DateTime>, IEquatable<Time>, IEquatable<DateTime>
    {
        /// <summary>
        /// The value this Time wraps
        /// </summary>
        public DateTime Value;

        /// <summary>
        /// Initializes a new Time object
        /// </summary>
        public Time(DateTime value)
        {
            Value = value;
        }

        Type ITObject.Native => typeof(DateTime);

        bool IConvertible.ToBoolean(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToBoolean(provider);
        }

        char IConvertible.ToChar(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToChar(provider);
        }

        sbyte IConvertible.ToSByte(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToSByte(provider);
        }

        byte IConvertible.ToByte(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToByte(provider);
        }

        short IConvertible.ToInt16(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToInt16(provider);
        }

        int IConvertible.ToInt32(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToInt32(provider);
        }

        long IConvertible.ToInt64(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToInt64(provider);
        }

        ushort IConvertible.ToUInt16(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToUInt16(provider);
        }

        uint IConvertible.ToUInt32(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToUInt32(provider);
        }

        ulong IConvertible.ToUInt64(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToUInt64(provider);
        }

        float IConvertible.ToSingle(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToSingle(provider);
        }

        double IConvertible.ToDouble(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToDouble(provider);
        }

        decimal IConvertible.ToDecimal(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToDecimal(provider);
        }

        DateTime IConvertible.ToDateTime(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToDateTime(provider);
        }

        string IConvertible.ToString(IFormatProvider provider)
        {
            return ((IConvertible)Value).ToString(provider);
        }

        TypeCode IConvertible.GetTypeCode()
        {
            return Value.GetTypeCode();
        }

        object IConvertible.ToType(Type conversionType, IFormatProvider provider)
        {
            return ((IConvertible)Value).ToType(conversionType, provider);
        }
        /// <summary>
        /// Determines if this Time object is equal to another
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(Time other)
        {
            return Value == other.Value;
        }

        /// <summary>
        /// Determines if this Time object is equal to a DateTime
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(DateTime other)
        {
            return Value == other;
        }
        
        /// <summary>
        /// Determines if these two objects are equal
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
            Time? n = obj as Time?;
            if (n != null)
                return Equals(n.Value);

            DateTime? v = obj as DateTime?;
            if (v != null)
                return Equals(v.Value);

            return false;
        }

        /// <summary>
        /// Gets the hash code for this Time object
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }
        /// <summary>
        /// Compares this Time with another object
        /// </summary>
        /// <param name="obj">the other object</param>
        /// <returns></returns>
        public int CompareTo(object obj)
        {
            Time? n = obj as Time?;
            if (n != null)
                return CompareTo(n.Value);

            DateTime? d = obj as DateTime?;
            if (n != null)
                return CompareTo(d.Value);

            throw new ArgumentException($"Cannot compare types {nameof(Time)} and \"{TypeUtil.NameOf(obj)}\"");
        }

        /// <summary>
        /// Compares this Time object to another Time object
        /// </summary>
        /// <param name="other">the other Time object</param>
        /// <returns></returns>
        public int CompareTo(Time other)
        {
            return Value.CompareTo(other.Value);
        }

        /// <summary>
        /// Compares this Time to a DateTime
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public int CompareTo(DateTime other)
        {
            return Value.CompareTo(other);
        }

        /// <summary>
        /// Implicitly converts a DateTime to a Time
        /// </summary>
        /// <param name="value"></param>
        public static implicit operator Time(DateTime value)
        {
            return new Time(value);
        }

        /// <summary>
        /// Implicitly converts a Time to a DateTime
        /// </summary>
        /// <param name="value"></param>
        public static implicit operator DateTime(Time value)
        {
            return value.Value;
        }
        /// <summary>
        /// Determines if one Time object is equal to another Time object
        /// </summary>
        /// <param name="left">the left operand</param>
        /// <param name="right">the right operand</param>
        /// <returns>a boolean value indicating if the expression is true of false</returns>
        public static bool operator ==(Time left, Time right)
        {
            return left.Value == right.Value;
        }

        /// <summary>
        /// Determines if one Time object is not equal to another Time object
        /// </summary>
        /// <param name="left">the left operand</param>
        /// <param name="right">the right operand</param>
        /// <returns>a boolean value indicating if the expression is true of false</returns>
        public static bool operator !=(Time left, Time right)
        {
            return left.Value != right.Value;
        }

        /// <summary>
        /// Determines if one Time object is greater than another Time object
        /// </summary>
        /// <param name="left">the left operand</param>
        /// <param name="right">the right operand</param>
        /// <returns>a boolean value indicating if the expression is true of false</returns>
        public static bool operator >(Time left, Time right)
        {
            return left.Value > right.Value;
        }

        /// <summary>
        /// Determines if one Time object is less than another Time object
        /// </summary>
        /// <param name="left">the left operand</param>
        /// <param name="right">the right operand</param>
        /// <returns>a boolean value indicating if the expression is true of false</returns>
        public static bool operator <(Time left, Time right)
        {
            return left.Value < right.Value;
        }

        /// <summary>
        /// Determines if one Time object is greater than or equal to another Time object
        /// </summary>
        /// <param name="left">the left operand</param>
        /// <param name="right">the right operand</param>
        /// <returns>a boolean value indicating if the expression is true of false</returns>
        public static bool operator >=(Time left, Time right)
        {
            return left.Value >= right.Value;
        }

        /// <summary>
        /// Determines if one Time object is less than or equal to another Time object
        /// </summary>
        /// <param name="left">the left operand</param>
        /// <param name="right">the right operand</param>
        /// <returns>a boolean value indicating if the expression is true of false</returns>
        public static bool operator <=(Time left, Time right)
        {
            return left.Value <= right.Value;
        }


        /// <summary>
        /// Tries to parse a string as a Time object
        /// </summary>
        /// <param name="str"></param>
        /// <param name="result"></param>
        /// <returns></returns>
        public static bool TryParse(string str, out Time result)
        {
            result = default;
            if (DateTime.TryParse(str, out DateTime native)) {
                result = native;
                return true;
            }
            return false;
        }

        /// <summary>
        /// Parses a string as a Time object
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        public static Time Parse(string str)
        {
            return DateTime.Parse(str);
        }
    }
}
