<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".Generated.cs" #>
// ======
//
// Copyright (c) Timothy Baxendale. All Rights Reserved.
//
// ======
using System;
using System.Collections.Generic;
using TLang.Errors;
using TLang.Types;

namespace TLang.Runtime
{
    // Autogenerated. Do not modify this file.
    public partial class ObjectContext
    {
<#	BuildGroup("Function", "CallData", "_functions");
    BuildGroup("Command", "CallData", "_commands");
    BuildGroup("Function", "TBasicFunction", "_functions", non_overloadable: false, castType: "CallData");
    BuildGroup("Command", "TBasicFunction", "_commands", non_overloadable: false, castType: "CallData");
    BuildGroup("Block", "BlockCreator", "_blocks");
    BuildGroup("Type", "TClass", "_prototypes");
    BuildGroup("BinaryOperator", "BinaryOperator", "_binaryOps", list: false);
    BuildGroup("UnaryOperator", "UnaryOperator", "_unaryOps", list: false);
#>
        #region Misc Generated
<#

    BuildFindContext("Variable", "object", "_variables");
    BuildFindContext("Constant", "object", "_constants");
#>

        #endregion
    }
}
<#+
    private void BuildGroup(string name, string type, string dict, bool list = true, bool non_overloadable = true, string castType = null)
    {
#>
        #region Generated <#= name #>.<#= type #> methods 

<#+
        BuildSet(name, type, dict);
        WriteLine("");
        BuildAdd(name, type, dict);
        WriteLine("");
        BuildTryGet(name, type, dict, castType);
        WriteLine("");
        if (non_overloadable) {
            BuildGet(name, type, dict);
            WriteLine("");
            BuildFindContext(name, type, dict);
            WriteLine("");
            if (list) {
                BuildList(name, type, dict);
                WriteLine("");
                BuildListAll(name, type, dict);
                WriteLine("");
            }
            BuildRemove(name, type, dict);
            WriteLine("");
        }
#>
        #endregion

<#+
    }
#>
<#+ private void BuildTryGet(string name, string type, string dict, string castType = null)
    {
#>
        /// <summary>
        /// Tries to get a <#= name #> from this context
        /// </summary>
        /// <returns>true if the <#= name #> was found, otherwise false.</returns>
        public bool TryGet<#= name #>(string name, out <#= type #> value)
        {
<#+ if (castType == null) { #>
            if (<#= dict #>.TryGetValue(name, out value)) {
<#+ } 
    else { #>
            <#= castType #> tmp;
            if (<#= dict #>.TryGetValue(name, out tmp)) {
                value = (<#= type #>)tmp;
<#+ } #>
                return true;
            }
            else if (_super == null) {
<#+ if (castType != null) { #>
                value = default(<#= type #>);
<#+ } #>
                return false;
            }
            else {
                return _super.TryGet<#= name #>(name, out value);
            }
        }
<#+
    }
#>
<#+ private void BuildGet(string name, string type, string dict)
    {
#>
        /// <summary>
        /// Gets a <#= name #> if it exists, throws an ArgumentException otherwise
        /// </summary>
        /// <param name="name">the <#= name #> as a string</param>
        /// <exception cref="ArgumentException">thrown if the <#= name #> is undefined</exception>
        /// <returns></returns>
        public <#= type #> Get<#= name #>(string name)
        {
            <#= type #> value;
            if (<#= dict #>.TryGetValue(name, out value)) {
                return value;
            }
            else if (_super == null) {
                throw ThrowHelper.UndefinedObject(name);
            }
            else {
                return _super.Get<#= name #>(name);
            }
        }
<#+
    }
#>
<#+ private void BuildSet(string name, string type, string dict)
    {
#>
        /// <summary>
        /// Sets a <#= name #> in this context. If the <#= name #> exists, it is set in
        /// the context in which it was declared. Otherwise, it is declared in this context.
        /// </summary>
        public void Set<#= name #>(string name, <#= type #> value)
        {
            ObjectContext c = Find<#= name #>Context(name);
            if (c != null) {
                c.<#= dict #>[name] = value;
            }
            else {
                Add<#= name #>(name, value);
            }
        }
<#+
    }
#>
<#+ private void BuildFindContext(string name, string type, string dict)
    {
#>
        /// <summary>
        /// Searches for the context in which a <#= name #> is declared. If the <#= name #> cannot be found, null is returned.
        /// </summary>
        /// <param name="name">the block name</param>
        /// <returns>the ObjectContext in which the block is declared</returns>
        public ObjectContext Find<#= name #>Context(string name)
        {
            if (<#= dict #>.ContainsKey(name)) {
                return this;
            }
            else if (_super == null) {
                return null;
            }
            else {
                return _super.Find<#= name #>Context(name);
            }
        }
<#+
    }
#>
<#+ private void BuildAdd(string name, string type, string dict)
    {
#>
        /// <summary>
        /// Adds a <#= name#> to this context. If the <#= name#> exists, an exception is thrown
        /// </summary>
        public void Add<#= name #>(string name, <#= type #> value)
        {
			try {
				<#= dict #>.Add(name, value);
			}
			catch(ArgumentException) {
				throw new DuplicateDefinitionException(name);
			}
        }
<#+
    }
#>
<#+ private void BuildRemove(string name, string type, string dict)
    {
#>
        /// <summary>
        /// Removes a <#= name#> from this context
        /// </summary>
        /// <returns>true if the remove was successful, false otherwise</returns>
        public bool Remove<#= name #>(string name)
        {
            return <#= dict #>.Remove(name);
        }
<#+
    }
#>
<#+ private void BuildListAll(string name, string type, string dict)
    {
#>
        /// <summary>
        /// Lists all the <#= name #>s currently defined
        /// </summary>
        /// <returns></returns>
        public IEnumerable<KeyValuePair<string, <#= type #>>> GetAll<#= name #>s()
        {
            ObjectContext context = this;
            while (context != null) {
                foreach (var value in context.GetLocal<#= name #>s()) {
                    yield return value;
                }
                context = context._super;
            }
        }
<#+
    }
#>
<#+ private void BuildList(string name, string type, string dict)
    {
#>
        /// <summary>
        /// Lists all the <#= name #>s currently defined in this context
        /// </summary>
        /// <returns></returns>
        public IEnumerable<KeyValuePair<string, <#= type #>>> GetLocal<#= name #>s()
        {
            return <#= dict #>;
        }
<#+
    }
#>