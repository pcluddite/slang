/** +++====+++
 *  
 *  Copyright (c) Timothy Baxendale
 *
 *  +++====+++
**/
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using System;
using System.Globalization;

namespace Slang.Types
{
    // Autogenerated. Do not modify this file.
<# BuildType("Number", "double", partial: true); #>
<# BuildType("Time", "DateTime"); #>
}
<#+
private void BuildType(string typeName, string nativeType, bool partial = false)
{
    string modifiers = "public";
    if (partial) {
        modifiers = "public partial";
    }
#>

    /// <summary>
    /// The runtime object for a <#=nativeType#>
    /// </summary>
    <#=modifiers#> struct <#=typeName#>
        : ITObject, IConvertible, IComparable, IComparable<<#=typeName#>>, IComparable<<#=nativeType#>>, IEquatable<<#=typeName#>>, IEquatable<<#=nativeType#>>
    {
        /// <summary>
        /// The value this <#=typeName#> wraps
        /// </summary>
        public <#=nativeType#> Value;

        /// <summary>
        /// Initializes a new <#=typeName#> object
        /// </summary>
        public <#=typeName#>(<#=nativeType#> value)
        {
            Value = value;
        }

        Type ITObject.Native => typeof(<#=nativeType#>);
<#+
BuildIConvertible();
BuildIEquatable(typeName, nativeType);
BuildIComparable(typeName, nativeType);
BuildOperators(typeName, nativeType);
#>

        /// <summary>
        /// Tries to parse a string as a <#=typeName#> object
        /// </summary>
        /// <param name="str"></param>
        /// <param name="result"></param>
        /// <returns></returns>
        public static bool TryParse(string str, out <#=typeName#> result)
        {
            result = default;
            if (<#=nativeType#>.TryParse(str, out <#=nativeType#> native)) {
                result = native;
                return true;
            }
            return false;
        }

        /// <summary>
        /// Parses a string as a <#=typeName#> object
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        public static <#=typeName#> Parse(string str)
        {
            return <#=nativeType#>.Parse(str);
        }
    }
<#+
}

private void BuildIComparable(string typeName, string nativeType)
{
#>
        /// <summary>
        /// Compares this <#=typeName#> with another object
        /// </summary>
        /// <param name="obj">the other object</param>
        /// <returns></returns>
        public int CompareTo(object obj)
        {
            <#=typeName#>? n = obj as <#=typeName#>?;
            if (n != null)
                return CompareTo(n.Value);

            <#=nativeType#>? d = obj as <#=nativeType#>?;
            if (n != null)
                return CompareTo(d.Value);

            throw new ArgumentException($"Cannot compare types {nameof(<#=typeName#>)} and \"{TypeUtil.NameOf(obj)}\"");
        }

        /// <summary>
        /// Compares this <#=typeName#> object to another <#=typeName#> object
        /// </summary>
        /// <param name="other">the other <#=typeName#> object</param>
        /// <returns></returns>
        public int CompareTo(<#=typeName#> other)
        {
            return Value.CompareTo(other.Value);
        }

        /// <summary>
        /// Compares this <#=typeName#> to a <#=nativeType#>
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public int CompareTo(<#=nativeType#> other)
        {
            return Value.CompareTo(other);
        }
<#+
}

private void BuildIConvertible()
{
	BuildIConvertible("bool", "Boolean");
	BuildIConvertible("char", "Char");
	BuildIConvertible("sbyte", "SByte");
	BuildIConvertible("byte", "Byte");
	BuildIConvertible("short", "Int16");
	BuildIConvertible("int", "Int32");
	BuildIConvertible("long", "Int64");
	BuildIConvertible("ushort", "UInt16");
	BuildIConvertible("uint", "UInt32");
	BuildIConvertible("ulong", "UInt64");
	BuildIConvertible("float", "Single");
	BuildIConvertible("double", "Double");
	BuildIConvertible("decimal", "Decimal");
	BuildIConvertible("DateTime", "DateTime");
	BuildIConvertible("string", "String");
#>

        TypeCode IConvertible.GetTypeCode()
        {
            return Value.GetTypeCode();
        }

        object IConvertible.ToType(Type conversionType, IFormatProvider provider)
        {
            return ((IConvertible)Value).ToType(conversionType, provider);
        }
<#+
}

private void BuildIConvertible(string type, string sigtype)
{
#>

        <#= type #> IConvertible.To<#= sigtype #>(IFormatProvider provider)
        {
            return ((IConvertible)Value).To<#= sigtype #>(provider);
        }
<#+
}

private void BuildIEquatable(string typeName, string nativeType) {
#>
        /// <summary>
        /// Determines if this <#=typeName#> object is equal to another
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(<#=typeName#> other)
        {
            return Value == other.Value;
        }

        /// <summary>
        /// Determines if this <#=typeName#> object is equal to a <#=nativeType#>
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(<#=nativeType#> other)
        {
            return Value == other;
        }
        
        /// <summary>
        /// Determines if these two objects are equal
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
            <#=typeName#>? n = obj as <#=typeName#>?;
            if (n != null)
                return Equals(n.Value);

            <#=nativeType#>? v = obj as <#=nativeType#>?;
            if (v != null)
                return Equals(v.Value);

            return false;
        }

        /// <summary>
        /// Gets the hash code for this <#=typeName#> object
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }
<#+
}

private void BuildOperators(string typeName, string nativeType)
{
#>

        /// <summary>
        /// Implicitly converts a <#=nativeType#> to a <#=typeName#>
        /// </summary>
        /// <param name="value"></param>
        public static implicit operator <#=typeName#>(<#=nativeType#> value)
        {
            return new <#=typeName#>(value);
        }

        /// <summary>
        /// Implicitly converts a <#=typeName#> to a <#=nativeType#>
        /// </summary>
        /// <param name="value"></param>
        public static implicit operator <#=nativeType#>(<#=typeName#> value)
        {
            return value.Value;
        }
<#+
    
	BuildBoolOp(typeName, nativeType, "==", "equal to");
	BuildBoolOp(typeName, nativeType, "!=", "not equal to");
	BuildBoolOp(typeName, nativeType, ">", "greater than");
	BuildBoolOp(typeName, nativeType, "<", "less than");
	BuildBoolOp(typeName, nativeType, ">=", "greater than or equal to");
	BuildBoolOp(typeName, nativeType, "<=", "less than or equal to");
}

private void BuildBoolOp(string typeName, string nativeType, string op, string descrip)
{
#>
        /// <summary>
        /// Determines if one <#=typeName#> object is <#= descrip #> another <#=typeName#> object
        /// </summary>
        /// <param name="left">the left operand</param>
        /// <param name="right">the right operand</param>
        /// <returns>a boolean value indicating if the expression is true of false</returns>
        public static bool operator <#= op #>(<#=typeName#> left, <#=typeName#> right)
        {
            return left.Value <#= op #> right.Value;
        }

<#+
}
#>