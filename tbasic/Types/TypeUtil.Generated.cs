/** +++====+++
 *  
 *  Copyright (c) Timothy Baxendale
 *
 *  +++====+++
**/
using System;
using Tbasic.Runtime;

namespace Tbasic.Types
{
    // Autogenerated. Do not modify this file.
    internal static partial class TypeUtil
    {
        /// <summary>
        /// Tries to convert an object to a given type. First this tries to do a straight up cast. If that doesn't work and strict is turned off, it will try to be converted with IConvertible. If the object is a string and parseStrings is turned on, it will try to parse that string.
        /// </summary>
        /// <typeparam name="T">the type to convert to</typeparam>
        /// <param name="obj">the object to convert</param>
        /// <param name="result">the result of the conversion</param>
        /// <param name="opts">the options for converting</param>
        /// <returns></returns>
        internal static bool TryConvert<T>(object obj,  out T result, ExecutorOption opts)
        {
            if (obj is T) {
                result = (T)obj;
                return true;
            }
            else {
                if (!opts.HasFlag(ExecutorOption.Strict))
                    return TryConvertNonStrict(obj, out result, opts);
                result = default;
                return false;
            }
        }

        /// <summary>
        /// Tries to convert an object to a given type. First this tries to do a straight up cast. If that doesn't work and strict is turned off, it will try to be converted with IConvertible. If the object is a string and parseStrings is turned on, it will try to parse that string.
        /// </summary>
        /// <param name="type">the type to convert to</param>
        /// <param name="obj">the object to convert</param>
        /// <param name="result">the result of the conversion</param>
        /// <param name="opts">the options for converting</param>
        /// <returns></returns>
        internal static bool TryConvert(object obj,  Type type, out object result, ExecutorOption opts)
        {
            if (type.IsAssignableFrom(obj.GetType())) {
                result = obj;
                return true;
            }
            else {
                if (!opts.HasFlag(ExecutorOption.Strict))
                    return TryConvertNonStrict(obj, type, out result, opts);
                result = default;
                return false;
            }
        }

        private static bool TryConvertNonStrict<T>(object obj, out T result, ExecutorOption opts)
        {
            result = default;
            if (obj == null)
                return false;

            if (!opts.HasFlag(ExecutorOption.EnforceStrings)) {
                string str = obj as string; // maybe we can convert it from a string?
                if (str != null) {
                    obj = ConvertFromString(str);
                    if (obj == null)
                        return false;
                    return TryConvert(obj, out result, ExecutorOption.None); // it's a good old fashion type now. try again.
                }
            }

            IConvertible c = obj as IConvertible;
            if (c == null)
                return false;

            try {
                result = (T)Convert.ChangeType(obj, typeof(T));
                return true;
            }
            catch(InvalidCastException) {
                if (typeof(T).IsEnum) {
                    Number? n = obj as Number?;
                    if (n != null) {
                        return TryConvert((long)n, out result, ExecutorOption.Strict); // if we don't turn on strict, we'll have infinite recursion 8/22/16
                    }
                }
                return false;
            }
            catch (Exception ex) when (ex is FormatException || ex is OverflowException) {
                return false;
            }
        }

        private static bool TryConvertNonStrict(object obj, Type type, out object result, ExecutorOption opts)
        {
            result = default;
            if (obj == null)
                return false;

            if (!opts.HasFlag(ExecutorOption.EnforceStrings)) {
                string str = obj as string; // maybe we can convert it from a string?
                if (str != null) {
                    obj = ConvertFromString(str);
                    if (obj == null)
                        return false;
                    return TryConvert(obj, out result, ExecutorOption.None); // it's a good old fashion type now. try again.
                }
            }

            IConvertible c = obj as IConvertible;
            if (c == null)
                return false;

            try {
                result = Convert.ChangeType(obj, type);
                return true;
            }
            catch(InvalidCastException) {
                if (type.IsEnum) {
                    Number? n = obj as Number?;
                    if (n != null) {
                        return TryConvert((long)n, out result, ExecutorOption.Strict); // if we don't turn on strict, we'll have infinite recursion 8/22/16
                    }
                }
                return false;
            }
            catch (Exception ex) when (ex is FormatException || ex is OverflowException) {
                return false;
            }
        }
    }
}
